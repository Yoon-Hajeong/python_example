# # a = [1,2,3,"good"]
# # a[0] = 3
# # print(a)
# # #이렇게 숫자를 바꿀 수 있음, 문자도 바꿀 수 있음
# # a[3] = "3333"
# # print(a)
# # #이거는 뭘까?
# # a[3][1] = "g" #이거는 오류뜸. 의도한것은 agaa이지만, 이게 불가능ㅠ 스트링의 문자열 값은 바꿀 수 없다.(문자열 특징)
# # #문자열의 특성값을 새로운 문자열로 대체할 수 없다. 그냥 새로운 문자열을 만들어야 한다.
# # #그렇다면 리스트 안에 중복값이 들어갈 수 있을까? 있다.
# # a = [1,2,3,1,2,3,4,5,"good"]
# # #하지만 중복을 허용하지 않는 자료구조도 있다.

# li = []
# li.append(1) #추가하고 싶으면 어펜드
# li.append(2) #순서는 [1,2,,,,] 이런식으로 쌓임
# li.append([1,2,3]) #이렇게는 될까?
# print(li) #어펜드는 많이 쓰는 기능
# #확장개념
# li[2].append("good") #li[2]도 리스트 타입이기 때문에 append할 수 있다.
# print(li)

# #데이터 삭제, clear(리스트 안에 있는 데이터만 삭제한다.)
# li.clear()
# print(li) #오류가 안남. 리스트 안의 데이터만 삭제하고 리스트 자체는 남아있음

# #복제하기!
# b = [1,2,3] #b를 c에 복사하고 싶다면?***중요
# c = b #이렇게 할당한다면?
# # c.append(123)
# print(b) #123이 들어가버림. 의도한대로 안나옴. b를 출력했는데...?
# #컴퓨터의 특징 중 하나. b는 c랑 동기화 된 것임. 즉 b를 수정하면 c도 수정되는 것.(연동되었으니까)
# #그래서 복제 한다면 이렇게 하면 안된다! 복제 기능이 따로 있음
# c = b.copy()
# c.append(2)
# print(b)
# print(c)

# """
# <복습하기>
# 빈리스트를 만든다.
# append를 사용하여 이중 리스트를 만든다.
# 출력한다.
# 리스트의 데이터를 다 지운다.
# 출력한다.
# copy를 활용한다.
# 카피를 활용한 리스트에 append를 사용하여 출력한다.
# """

# a = [5, 6, 7]
# a.append(["good", 8])
# print(a)
# a.clear()
# print(a)
# b = a.copy()
# b.append(3)
# print(a)
# print(b)

# #답
# a = []

# a.append([1,2,3])
# print(a)
# a.clear()
# print(a)
# a = [1,2,3]
# b = a.copy()
# b.append(4)
# print(b)

# # 리스트 안에서 특정 문자나 숫자를 세는 기능? count
# a = [1, 2, 3, "okay", 1, 1, 1]
# print(a.count(1))
# b = [1, 2, 3, [1, 2, 3, 1]]
# print(b.count(1))
# # 왜 1이 나올까? b는 리스트. 1은 딱 숫자임. 근데 b입장에서 [1,2,3,1]은 리스트라서 매칭이 안됨
# # 이 형태에서 카운트 써서 3을 출력하도록 해보자
# print(b.count(1) + b[3].count(1))
# #shift, alt f키 누르면 자동 정렬됨

# # extend와 순회
# a = [1, 2, 3, 4]
# b = [5, 6, 7, 8]
# # [1,2,3,4,5,6,7,8] 을 만들고 싶은 상황
# a.extend(b)
# print(a)
# # a.append(5),,,이렇게 해도 되는데, extend로 하면 순회가 가능하게 됨(반복문)
# # 순회 : 5부터 8까지 갈 수 있다. 문자열은 순회가 가능할까?
# #문자열은 각 문자로 구성되어 있음.
# c = "good"
# b.extend(c)
# print(b)
# #문자열은 쪼개져서 들어감. 반복될 수 있는 데이터를 집어넣는 기능이 바로 extend.

# #리스트에서 값을 찾는 기능 : find/index 리스트에서는 인덱스만 됨.
# a = ["good", "okay"]
# # b = a.index("aaaa") #aaaa의 위치를 가져오는 것
# # print(b)
# c = a.index("okay")
# print(c)

# #정리 : 
# # 리스트는 인덱스가 있으니까 반복할 수 있다
# # 스택 형식을 따른다
# # 중복형태가 가능하다
# # 중복리스트 만들 수 있다
# # 왼쪽에서 오른쪽으로 쌓인다

# #예외처리하는법
# try:
#     a.index('aaa')
# except:
#     print("에러")












































