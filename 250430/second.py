# a = "good"
# b = "a" in a
# print(len(a)) 
# #len 은 length의 줄임말. 문자열의 길이를 측정. 셀 수 있음

# li = [10,20,30,40] #장바구니에 묶어줌 인덱스 2는 30
# a = "a씨"
# b = "b씨" #상당히 비효율적임
# x = [1,2,3] #x입장에서는 자료  1개임. 덩어리 리스트형 하나. 그 안에 3개의 데이터가 있는것
# y = ['apple','banana','cherry',1] #문자. 리스트 안에는 여러가지 데이터 타입들이 들어갈 수 있다
# z = [1,[2],3] in [2] #리스트 안에 리스트를 넣을 수 있을까? ㅇㅇ. 이것을 중첩리스트라고 함
# #리스트를 쓰는 이유? 저 위의 것들을 Data라고 생각해보자. 리스트 안에서 뺐다 넣었다 찾았다 가능
# #BUt 
# t = ['a',['c','d'],'e'] #t의 입장에서 리스트 값은? 3개. 첫번째 인덱스 자료형은? ['c','d']
# z = [1,[2],3] in [2]# 이것은 T? F? F임. T가 되려면, [1,[2],3] in [2,3,2132,13,[1,[2],3]]
# print(z)

# test = [1,2,3] in [1,2,[1,2,3]] #[1,2,3]인 리스트를 찾는 것. 숫자를 찾는게 아님
# print(test)

# #리스트 여러 중으로 있으면 가독성 최악임, 3/4중까지는 납득가능...
# candy = [['딸기', ['딸기바나나']], ['초코', ['초코바나나']], [['딸기바나나', '초코바나나']]]
# check = [['딸기바나나', '초코바나나']] in candy
# print(check)

# print(len(candy))
# t = [1,2,3,[4,5,6]] #인덱스로 어떻게 뽑아낼까?
# a = t[3] #인덱스를 통해 데이터를 가져왔다. 인덱싱
# t2 = [1,2,3,[4,5,[2,31]],1] #여기서 [4,5,[2,31]] 뽑아내려면?
# print(t2[3])
# #중첩 리스트는?
# print(t2[3][2])#3번째에 2번째
# #리스트는 수정 가능할까? 리스트를 통해 수정가능. 위치를 알고있기 때문.
# t2[0] = 5

# t3 = [5,4,3,[2,1]] #이것을 [1,2,3,[4,5]]로 바꾸기
# # t4 = [1,2,3,[4,5]]
# t3[0] = 1
# t3[1] = 2
# t3[3] = [4,5]
# print(t3)

#빈 껍데기 리스트 만들기
t4 = []
t4.append(1)
t4.append(2)
#append 는 기존에 있는 리스트에 뒤에다 붙이는 것
t4.clear() #리스트 안의 데이터가 삭제
t4.remove(3) #리스트 안에서 특정값을 지운다.
t4.sort() #오름차순 정렬 t4 = [5,4,3,2,1]을 [1,2,3,4,5]로 만들어줌
#그러나 오리지널 데이터는 남겨놔야 함
#대신 sorted() 기능이 존재함

#리스트 선언할 때 방법
a = []
b = list() #it also works 다른 기능이랑 접할 때, 형변환 필요할 때 아래 표현 필요함

t4.pop() #뽑는 것. 왼쪽기준? 오른쪽기준? append는 오른쪽부터 차곡차곡쌓임.
#뽑고나서 실제 데이터 : 4개가 원래 였으면, 3개. 추출하면 원래 데이터를 모르기 때문에 저장함
data = t4.pop() #last in first out 선입선출과 반대. 마지막 데이터를 첫번째로 삭제되니까









